<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>see.base_classes API documentation</title>
<meta name="description" content="The base_classes module is used for the rest of the image grammar to set up base classes." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>see.base_classes</code></h1>
</header>
<section id="section-intro">
<p>The base_classes module is used for the rest of the image grammar to set up base classes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;The base_classes module is used for the rest of the image grammar to set up base classes.&#34;&#34;&#34;
import copy
import time    
import random

class pipedata(object):
    &#34;&#34;&#34;The pipedata is just an instance of a basic python object. It is used to dynamically
    store output data from a wide variety of algorithms. Most algorithms in the pipe jsut add
    data to this objet which is passed in as an input argument and returned as an output argument.
    &#34;&#34;&#34;
    pass

class param_space(dict):
    &#34;&#34;&#34;Construct an parameter dictionary that represents the search space.

    Components:
        pkeys - paramters keys used by the current algorithsm.
        descriptions - Descriptions of the parameters
        ranges - List of possible choices for each parameter.
    &#34;&#34;&#34;
    
    descriptions = dict()
    ranges = dict()
    pkeys = []
    
    @classmethod
    def add(cls, key, prange, description):
        &#34;&#34;&#34;This is a class function which adds in parameters. 
        
        Inputs:
            key - the paramter name
            prange - the parameter range
            description - the description of the parameter
        &#34;&#34;&#34;
        cls.descriptions[key] = description
        cls.ranges[key] = prange
        if not key in cls.pkeys:
            cls.pkeys.append(key)

    def addall(self,params):
        &#34;&#34;&#34;Function to add a list of paramters to the current paramter list&#34;&#34;&#34;
        for key in params:
            self.add(key, params.ranges[key], params.descriptions[key])
            self[key] = params[key]
                            
    def printparam(self, key):
        &#34;&#34;&#34;Return description of parameter from param list.&#34;&#34;&#34;
        
        outstring = f&#34;{key}={self[key]}\n\t{self.descriptions[key]}&#34;
        
        if len(self.ranges) &lt; 10:
            outstring += &#34;\n\t{self.ranges[key]}\n\n&#34;
        else:
            outstring += &#34;\n\t{self.ranges[key][:2]}...{self.ranges[key][-2:]}\n\n&#34;
        
        return outstring

#     def __str__(self):
#         &#34;&#34;&#34;Return descriptions of all parameters in param list.&#34;&#34;&#34;
#         out = &#34;&#34;
#         for index, k in enumerate(self.pkeys):
#             out += f&#34;{index} &#34; + self.printparam(k)
#         return out

    def tolist(self):
        &#34;&#34;&#34;Convert dictionary of params into list of parameters.&#34;&#34;&#34;
        plist = []
        for key in self.pkeys:
            plist.append(self[key])
        return plist

    def fromlist(self, individual):
        &#34;&#34;&#34;Convert individual&#39;s list into dictionary of params.&#34;&#34;&#34;
        #logging.getLogger().info(f&#34;Parsing Parameter List for {len(individual)} parameters&#34;)
        for index, key in enumerate(self.pkeys):
            self[key] = individual[index]

class algorithm(object):
    &#34;&#34;&#34;Base class for any image alogirthm.
    
    Functions:
    evaluate -- Run segmentation algorithm to get inferred mask.

    &#34;&#34;&#34;
    
    def __init__(self, paramlist=None):
        &#34;&#34;&#34;Generate algorithm params from parameter list.&#34;&#34;&#34;
        self.params = param_space()
        self.set_params(paramlist)
    
    def set_params(self, paramlist=None):
        if paramlist:
            if (type(paramlist) == list):
                self.params.fromlist(paramlist)
            else:
                self.params = copy.deepcopy(paramlist)
        #self.checkparamindex()
        
    def checkparamindex(self):
        &#34;&#34;&#34;Check paramiter keys to ensure values are valid&#34;&#34;&#34;
        for myparams in self.params.pkeys:
            assert myparams in self.params, f&#34;ERROR {myparams} is not in parameter list&#34;
             
    def mutateself(self, flip_prob=0.5):
        &#34;&#34;&#34;Mutate self and return new params.&#34;&#34;&#34;
        for myparam in self.params.pkeys:
            rand_val = random.random()
            if rand_val &lt; flip_prob:
                self.params[myparam] = random.choice(eval(self.params.ranges[myparam]))
        return self.params
    
    def pipe(self, data):
        &#34;&#34;&#34;Run segmentation algorithm to get inferred mask.&#34;&#34;&#34;
        print(&#34;WARNING: Default Pipe, doing nothing\n&#34;)
        return data

    def __str__(self):
        &#34;&#34;&#34;Return params for algorithm.&#34;&#34;&#34;
        mystring = f&#34;{self.params[&#39;algorithm&#39;]} -- \n&#34;
        for p in self.params.pkeys:
            mystring += f&#34;\t{p} = {self.params[p]}\n&#34;
        return mystring

    def runAlgo(self, data, params=None):
        &#34;&#34;&#34;Run and evaluate the performance of an individual.

        Keyword arguments:
        data -- pipedata both input and output.
        params -- the list representing an individual in our population

        Output:
        fitness -- resulting fitness value for the individual
        mask -- resulting image mask associated with the individual (if return_mask=True)

        &#34;&#34;&#34;

        #TODO make this funciton more flexible and allow multiple types of params 
        # i&#39;m thinking (list, param_space and algorithm)
        startTime = int(round(time.time() * 1000))
        if params:
            seg = type(self)(paramlist=params)
            data = seg.pipe(data)
            endTime = int(round(time.time() * 1000))
            print(f&#34;{seg}Time: {(endTime - startTime)/1000} s&#34;)
        else:
            data = self.pipe(data) 
            endTime = int(round(time.time() * 1000))
            print(f&#34;{self}Time: {(endTime - startTime)/1000} s&#34;)
        
        return data    
    
def mutateAlgo(copy_child, pos_vals, flip_prob=0.5, seed=False):
    &#34;&#34;&#34;Generate an offspring based on current individual.&#34;&#34;&#34;
    
    #print(f&#34;copy_child = {type(copy_child)}&#34;)
    child = copy.deepcopy(copy_child)
    
    # Not every algorithm is associated with every value
    # Let&#39;s first see if we change the algorithm
    for index,vals in enumerate(pos_vals):
        rand_val = random.random()
        if rand_val &lt; flip_prob:
            # Let&#39;s mutate the algorithm
            child[index] = random.choice(pos_vals[index])

#     #use the local search for mutation.
#     seg = algoFromParams(child)
#     child = seg.mutateself(flip_prob)
    return child


def print_best_algorithm_code(individual):
    &#34;&#34;&#34;Print usable code to run segmentation algorithm based on an
     individual&#39;s genetic representation vector.&#34;&#34;&#34;
    pass

#TODO Try to fix this print. I&#39;m not sure the best way to generate an algorithm from parameters.
#     #ind_algo = Segmentors.algoFromParams(individual)
#     ind_algo = algoFromParams(individual)
#     original_function = inspect.getsource(ind_algo.evaluate)

#     # Get the body of the function
#     function_contents = original_function[original_function.find(&#39;        &#39;):\
#                             original_function.find(&#39;return&#39;)]
#     while function_contents.find(&#39;self.params&#39;) != -1:

#         # Find the index of the &#39;s&#39; at the start of self.params
#         params_index = function_contents.find(&#39;self.params&#39;)

#         # Find the index of the &#39;]&#39; at the end of self.params[&#34;&lt;SOME_TEXT&gt;&#34;]
#         end_bracket_index = function_contents.find(&#39;]&#39;, params_index)+1

#         # Find the first occurance of self.params[&#34;&lt;SOME_TEXT&gt;&#34;] and store it
#         code_to_replace = function_contents[params_index:end_bracket_index]

#         # These offset will be used to access only the params_key
#         offset = len(&#39;self.params[&#34;&#39;)
#         offset2 = len(&#39;&#34;]&#39;)

#         # Get the params key
#         params_key = function_contents[params_index + offset:end_bracket_index-offset2]

#         # Use the params_key to access the params_value
#         param_value = str(ind_algo.params[params_key])

#         # Replace self.params[&#34;&lt;SOME_TEXT&gt;&#34;] with the value of self.params[&#34;&lt;SOME_TEXT&gt;&#34;]
#         function_contents = function_contents.replace(code_to_replace, param_value)

#     function_contents = function_contents.replace(&#39;        &#39;, &#39;&#39;)
#     function_contents = function_contents[function_contents.find(&#39;\n\&#34;\&#34;\&#34;&#39;)+5:]
#     print(function_contents)
#     return function_contents
   
def popCounts(pop):
    &#34;&#34;&#34;Count the number of each algorihtm in a population&#34;&#34;&#34;
    algorithms = seg_params.ranges[&#34;algorithm&#34;]
    counts = {a:0 for a in algorithms}
    for p in pop:
        #print(p[0])
        counts[p[0]] += 1
    return counts</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="see.base_classes.mutateAlgo"><code class="name flex">
<span>def <span class="ident">mutateAlgo</span></span>(<span>copy_child, pos_vals, flip_prob=0.5, seed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an offspring based on current individual.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutateAlgo(copy_child, pos_vals, flip_prob=0.5, seed=False):
    &#34;&#34;&#34;Generate an offspring based on current individual.&#34;&#34;&#34;
    
    #print(f&#34;copy_child = {type(copy_child)}&#34;)
    child = copy.deepcopy(copy_child)
    
    # Not every algorithm is associated with every value
    # Let&#39;s first see if we change the algorithm
    for index,vals in enumerate(pos_vals):
        rand_val = random.random()
        if rand_val &lt; flip_prob:
            # Let&#39;s mutate the algorithm
            child[index] = random.choice(pos_vals[index])

#     #use the local search for mutation.
#     seg = algoFromParams(child)
#     child = seg.mutateself(flip_prob)
    return child</code></pre>
</details>
</dd>
<dt id="see.base_classes.popCounts"><code class="name flex">
<span>def <span class="ident">popCounts</span></span>(<span>pop)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the number of each algorihtm in a population</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popCounts(pop):
    &#34;&#34;&#34;Count the number of each algorihtm in a population&#34;&#34;&#34;
    algorithms = seg_params.ranges[&#34;algorithm&#34;]
    counts = {a:0 for a in algorithms}
    for p in pop:
        #print(p[0])
        counts[p[0]] += 1
    return counts</code></pre>
</details>
</dd>
<dt id="see.base_classes.print_best_algorithm_code"><code class="name flex">
<span>def <span class="ident">print_best_algorithm_code</span></span>(<span>individual)</span>
</code></dt>
<dd>
<div class="desc"><p>Print usable code to run segmentation algorithm based on an
individual's genetic representation vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_best_algorithm_code(individual):
    &#34;&#34;&#34;Print usable code to run segmentation algorithm based on an
     individual&#39;s genetic representation vector.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="see.base_classes.algorithm"><code class="flex name class">
<span>class <span class="ident">algorithm</span></span>
<span>(</span><span>paramlist=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for any image alogirthm.</p>
<p>Functions:
evaluate &ndash; Run segmentation algorithm to get inferred mask.</p>
<p>Generate algorithm params from parameter list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class algorithm(object):
    &#34;&#34;&#34;Base class for any image alogirthm.
    
    Functions:
    evaluate -- Run segmentation algorithm to get inferred mask.

    &#34;&#34;&#34;
    
    def __init__(self, paramlist=None):
        &#34;&#34;&#34;Generate algorithm params from parameter list.&#34;&#34;&#34;
        self.params = param_space()
        self.set_params(paramlist)
    
    def set_params(self, paramlist=None):
        if paramlist:
            if (type(paramlist) == list):
                self.params.fromlist(paramlist)
            else:
                self.params = copy.deepcopy(paramlist)
        #self.checkparamindex()
        
    def checkparamindex(self):
        &#34;&#34;&#34;Check paramiter keys to ensure values are valid&#34;&#34;&#34;
        for myparams in self.params.pkeys:
            assert myparams in self.params, f&#34;ERROR {myparams} is not in parameter list&#34;
             
    def mutateself(self, flip_prob=0.5):
        &#34;&#34;&#34;Mutate self and return new params.&#34;&#34;&#34;
        for myparam in self.params.pkeys:
            rand_val = random.random()
            if rand_val &lt; flip_prob:
                self.params[myparam] = random.choice(eval(self.params.ranges[myparam]))
        return self.params
    
    def pipe(self, data):
        &#34;&#34;&#34;Run segmentation algorithm to get inferred mask.&#34;&#34;&#34;
        print(&#34;WARNING: Default Pipe, doing nothing\n&#34;)
        return data

    def __str__(self):
        &#34;&#34;&#34;Return params for algorithm.&#34;&#34;&#34;
        mystring = f&#34;{self.params[&#39;algorithm&#39;]} -- \n&#34;
        for p in self.params.pkeys:
            mystring += f&#34;\t{p} = {self.params[p]}\n&#34;
        return mystring

    def runAlgo(self, data, params=None):
        &#34;&#34;&#34;Run and evaluate the performance of an individual.

        Keyword arguments:
        data -- pipedata both input and output.
        params -- the list representing an individual in our population

        Output:
        fitness -- resulting fitness value for the individual
        mask -- resulting image mask associated with the individual (if return_mask=True)

        &#34;&#34;&#34;

        #TODO make this funciton more flexible and allow multiple types of params 
        # i&#39;m thinking (list, param_space and algorithm)
        startTime = int(round(time.time() * 1000))
        if params:
            seg = type(self)(paramlist=params)
            data = seg.pipe(data)
            endTime = int(round(time.time() * 1000))
            print(f&#34;{seg}Time: {(endTime - startTime)/1000} s&#34;)
        else:
            data = self.pipe(data) 
            endTime = int(round(time.time() * 1000))
            print(f&#34;{self}Time: {(endTime - startTime)/1000} s&#34;)
        
        return data    </code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="see.ColorSpace.colorspace" href="ColorSpace.html#see.ColorSpace.colorspace">colorspace</a></li>
<li><a title="see.Segment_Fitness.segment_fitness" href="Segment_Fitness.html#see.Segment_Fitness.segment_fitness">segment_fitness</a></li>
<li><a title="see.Segmentors.segmentor" href="Segmentors.html#see.Segmentors.segmentor">segmentor</a></li>
<li><a title="see.Workflow.workflow" href="Workflow.html#see.Workflow.workflow">workflow</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="see.base_classes.algorithm.checkparamindex"><code class="name flex">
<span>def <span class="ident">checkparamindex</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check paramiter keys to ensure values are valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkparamindex(self):
    &#34;&#34;&#34;Check paramiter keys to ensure values are valid&#34;&#34;&#34;
    for myparams in self.params.pkeys:
        assert myparams in self.params, f&#34;ERROR {myparams} is not in parameter list&#34;</code></pre>
</details>
</dd>
<dt id="see.base_classes.algorithm.mutateself"><code class="name flex">
<span>def <span class="ident">mutateself</span></span>(<span>self, flip_prob=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutate self and return new params.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutateself(self, flip_prob=0.5):
    &#34;&#34;&#34;Mutate self and return new params.&#34;&#34;&#34;
    for myparam in self.params.pkeys:
        rand_val = random.random()
        if rand_val &lt; flip_prob:
            self.params[myparam] = random.choice(eval(self.params.ranges[myparam]))
    return self.params</code></pre>
</details>
</dd>
<dt id="see.base_classes.algorithm.pipe"><code class="name flex">
<span>def <span class="ident">pipe</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Run segmentation algorithm to get inferred mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipe(self, data):
    &#34;&#34;&#34;Run segmentation algorithm to get inferred mask.&#34;&#34;&#34;
    print(&#34;WARNING: Default Pipe, doing nothing\n&#34;)
    return data</code></pre>
</details>
</dd>
<dt id="see.base_classes.algorithm.runAlgo"><code class="name flex">
<span>def <span class="ident">runAlgo</span></span>(<span>self, data, params=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run and evaluate the performance of an individual.</p>
<p>Keyword arguments:
data &ndash; pipedata both input and output.
params &ndash; the list representing an individual in our population</p>
<p>Output:
fitness &ndash; resulting fitness value for the individual
mask &ndash; resulting image mask associated with the individual (if return_mask=True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runAlgo(self, data, params=None):
    &#34;&#34;&#34;Run and evaluate the performance of an individual.

    Keyword arguments:
    data -- pipedata both input and output.
    params -- the list representing an individual in our population

    Output:
    fitness -- resulting fitness value for the individual
    mask -- resulting image mask associated with the individual (if return_mask=True)

    &#34;&#34;&#34;

    #TODO make this funciton more flexible and allow multiple types of params 
    # i&#39;m thinking (list, param_space and algorithm)
    startTime = int(round(time.time() * 1000))
    if params:
        seg = type(self)(paramlist=params)
        data = seg.pipe(data)
        endTime = int(round(time.time() * 1000))
        print(f&#34;{seg}Time: {(endTime - startTime)/1000} s&#34;)
    else:
        data = self.pipe(data) 
        endTime = int(round(time.time() * 1000))
        print(f&#34;{self}Time: {(endTime - startTime)/1000} s&#34;)
    
    return data    </code></pre>
</details>
</dd>
<dt id="see.base_classes.algorithm.set_params"><code class="name flex">
<span>def <span class="ident">set_params</span></span>(<span>self, paramlist=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_params(self, paramlist=None):
    if paramlist:
        if (type(paramlist) == list):
            self.params.fromlist(paramlist)
        else:
            self.params = copy.deepcopy(paramlist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="see.base_classes.param_space"><code class="flex name class">
<span>class <span class="ident">param_space</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an parameter dictionary that represents the search space.</p>
<h2 id="components">Components</h2>
<p>pkeys - paramters keys used by the current algorithsm.
descriptions - Descriptions of the parameters
ranges - List of possible choices for each parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class param_space(dict):
    &#34;&#34;&#34;Construct an parameter dictionary that represents the search space.

    Components:
        pkeys - paramters keys used by the current algorithsm.
        descriptions - Descriptions of the parameters
        ranges - List of possible choices for each parameter.
    &#34;&#34;&#34;
    
    descriptions = dict()
    ranges = dict()
    pkeys = []
    
    @classmethod
    def add(cls, key, prange, description):
        &#34;&#34;&#34;This is a class function which adds in parameters. 
        
        Inputs:
            key - the paramter name
            prange - the parameter range
            description - the description of the parameter
        &#34;&#34;&#34;
        cls.descriptions[key] = description
        cls.ranges[key] = prange
        if not key in cls.pkeys:
            cls.pkeys.append(key)

    def addall(self,params):
        &#34;&#34;&#34;Function to add a list of paramters to the current paramter list&#34;&#34;&#34;
        for key in params:
            self.add(key, params.ranges[key], params.descriptions[key])
            self[key] = params[key]
                            
    def printparam(self, key):
        &#34;&#34;&#34;Return description of parameter from param list.&#34;&#34;&#34;
        
        outstring = f&#34;{key}={self[key]}\n\t{self.descriptions[key]}&#34;
        
        if len(self.ranges) &lt; 10:
            outstring += &#34;\n\t{self.ranges[key]}\n\n&#34;
        else:
            outstring += &#34;\n\t{self.ranges[key][:2]}...{self.ranges[key][-2:]}\n\n&#34;
        
        return outstring

#     def __str__(self):
#         &#34;&#34;&#34;Return descriptions of all parameters in param list.&#34;&#34;&#34;
#         out = &#34;&#34;
#         for index, k in enumerate(self.pkeys):
#             out += f&#34;{index} &#34; + self.printparam(k)
#         return out

    def tolist(self):
        &#34;&#34;&#34;Convert dictionary of params into list of parameters.&#34;&#34;&#34;
        plist = []
        for key in self.pkeys:
            plist.append(self[key])
        return plist

    def fromlist(self, individual):
        &#34;&#34;&#34;Convert individual&#39;s list into dictionary of params.&#34;&#34;&#34;
        #logging.getLogger().info(f&#34;Parsing Parameter List for {len(individual)} parameters&#34;)
        for index, key in enumerate(self.pkeys):
            self[key] = individual[index]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="see.ColorSpace.color_params" href="ColorSpace.html#see.ColorSpace.color_params">color_params</a></li>
<li><a title="see.Segmentors.seg_params" href="Segmentors.html#see.Segmentors.seg_params">seg_params</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="see.base_classes.param_space.descriptions"><code class="name">var <span class="ident">descriptions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="see.base_classes.param_space.pkeys"><code class="name">var <span class="ident">pkeys</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="see.base_classes.param_space.ranges"><code class="name">var <span class="ident">ranges</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="see.base_classes.param_space.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>key, prange, description)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a class function which adds in parameters. </p>
<h2 id="inputs">Inputs</h2>
<p>key - the paramter name
prange - the parameter range
description - the description of the parameter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def add(cls, key, prange, description):
    &#34;&#34;&#34;This is a class function which adds in parameters. 
    
    Inputs:
        key - the paramter name
        prange - the parameter range
        description - the description of the parameter
    &#34;&#34;&#34;
    cls.descriptions[key] = description
    cls.ranges[key] = prange
    if not key in cls.pkeys:
        cls.pkeys.append(key)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="see.base_classes.param_space.addall"><code class="name flex">
<span>def <span class="ident">addall</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to add a list of paramters to the current paramter list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addall(self,params):
    &#34;&#34;&#34;Function to add a list of paramters to the current paramter list&#34;&#34;&#34;
    for key in params:
        self.add(key, params.ranges[key], params.descriptions[key])
        self[key] = params[key]</code></pre>
</details>
</dd>
<dt id="see.base_classes.param_space.fromlist"><code class="name flex">
<span>def <span class="ident">fromlist</span></span>(<span>self, individual)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert individual's list into dictionary of params.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromlist(self, individual):
    &#34;&#34;&#34;Convert individual&#39;s list into dictionary of params.&#34;&#34;&#34;
    #logging.getLogger().info(f&#34;Parsing Parameter List for {len(individual)} parameters&#34;)
    for index, key in enumerate(self.pkeys):
        self[key] = individual[index]</code></pre>
</details>
</dd>
<dt id="see.base_classes.param_space.printparam"><code class="name flex">
<span>def <span class="ident">printparam</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Return description of parameter from param list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printparam(self, key):
    &#34;&#34;&#34;Return description of parameter from param list.&#34;&#34;&#34;
    
    outstring = f&#34;{key}={self[key]}\n\t{self.descriptions[key]}&#34;
    
    if len(self.ranges) &lt; 10:
        outstring += &#34;\n\t{self.ranges[key]}\n\n&#34;
    else:
        outstring += &#34;\n\t{self.ranges[key][:2]}...{self.ranges[key][-2:]}\n\n&#34;
    
    return outstring</code></pre>
</details>
</dd>
<dt id="see.base_classes.param_space.tolist"><code class="name flex">
<span>def <span class="ident">tolist</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert dictionary of params into list of parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tolist(self):
    &#34;&#34;&#34;Convert dictionary of params into list of parameters.&#34;&#34;&#34;
    plist = []
    for key in self.pkeys:
        plist.append(self[key])
    return plist</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="see.base_classes.pipedata"><code class="flex name class">
<span>class <span class="ident">pipedata</span></span>
</code></dt>
<dd>
<div class="desc"><p>The pipedata is just an instance of a basic python object. It is used to dynamically
store output data from a wide variety of algorithms. Most algorithms in the pipe jsut add
data to this objet which is passed in as an input argument and returned as an output argument.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pipedata(object):
    &#34;&#34;&#34;The pipedata is just an instance of a basic python object. It is used to dynamically
    store output data from a wide variety of algorithms. Most algorithms in the pipe jsut add
    data to this objet which is passed in as an input argument and returned as an output argument.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="see" href="index.html">see</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="see.base_classes.mutateAlgo" href="#see.base_classes.mutateAlgo">mutateAlgo</a></code></li>
<li><code><a title="see.base_classes.popCounts" href="#see.base_classes.popCounts">popCounts</a></code></li>
<li><code><a title="see.base_classes.print_best_algorithm_code" href="#see.base_classes.print_best_algorithm_code">print_best_algorithm_code</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="see.base_classes.algorithm" href="#see.base_classes.algorithm">algorithm</a></code></h4>
<ul class="">
<li><code><a title="see.base_classes.algorithm.checkparamindex" href="#see.base_classes.algorithm.checkparamindex">checkparamindex</a></code></li>
<li><code><a title="see.base_classes.algorithm.mutateself" href="#see.base_classes.algorithm.mutateself">mutateself</a></code></li>
<li><code><a title="see.base_classes.algorithm.pipe" href="#see.base_classes.algorithm.pipe">pipe</a></code></li>
<li><code><a title="see.base_classes.algorithm.runAlgo" href="#see.base_classes.algorithm.runAlgo">runAlgo</a></code></li>
<li><code><a title="see.base_classes.algorithm.set_params" href="#see.base_classes.algorithm.set_params">set_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="see.base_classes.param_space" href="#see.base_classes.param_space">param_space</a></code></h4>
<ul class="two-column">
<li><code><a title="see.base_classes.param_space.add" href="#see.base_classes.param_space.add">add</a></code></li>
<li><code><a title="see.base_classes.param_space.addall" href="#see.base_classes.param_space.addall">addall</a></code></li>
<li><code><a title="see.base_classes.param_space.descriptions" href="#see.base_classes.param_space.descriptions">descriptions</a></code></li>
<li><code><a title="see.base_classes.param_space.fromlist" href="#see.base_classes.param_space.fromlist">fromlist</a></code></li>
<li><code><a title="see.base_classes.param_space.pkeys" href="#see.base_classes.param_space.pkeys">pkeys</a></code></li>
<li><code><a title="see.base_classes.param_space.printparam" href="#see.base_classes.param_space.printparam">printparam</a></code></li>
<li><code><a title="see.base_classes.param_space.ranges" href="#see.base_classes.param_space.ranges">ranges</a></code></li>
<li><code><a title="see.base_classes.param_space.tolist" href="#see.base_classes.param_space.tolist">tolist</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="see.base_classes.pipedata" href="#see.base_classes.pipedata">pipedata</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>